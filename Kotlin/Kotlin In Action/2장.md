# 2. 코틀린 기초

## 2.1 기본 요소: 함수와 변수

> 코틀린이 변경 가능한 데이터보다 변경할 수 없는 불변 데이터 사용을 장려하는 이유
1. 안전성 향상 – 값이 바뀌지 않아 예기치 않은 버그나 동시성 문제를 예방한다.
2. 예측 가능성 – 상태 변화가 없어 코드 흐름을 추적하고 디버깅하기 쉽다.
3. 함수형 프로그래밍 친화성 – 부작용 없는(pure) 함수 작성이 가능해 코드 재사용성과 안정성이 높아진다.
4. 유지보수 용이 – 데이터가 외부에서 변경될 수 없으므로 코드 간섭이 줄고, 캡슐화가 강화된다.

### 코틀린 자바 차이
- 자바와 달리 함수를 최상위 수준에 정의할 수 있다.
- 배열 처리를 위한 문법이 존재하지 않는다.
- 표준 자바 라이브러리 함수를 간결하게 사용할 수 있게 감싼 Wrapper 를 제공한다.
- 줄 끝에 세미콜론을 붙이지 않아도 좋다.

### 코틀린에서의 함수
> 코틀린 if는 문장이 아닌 결과를 만드는 식(expression) 이다.

<details>
<summary>문장(statement) 와 식(expression) 차이</summary>
코틀린에서 if 는 식이지 문장이 아니다. <br/>
식: 값을 만들어 내고 다른 식의 하위 요소로 계산에 참여함. 하나의 값으로써의 역할이 크다.<br/>
문장: 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재 => 값을 만들어내지 않음.<br/>

반대로 대입문의 경우는 <br/>
자바에서는 **식**, 코틀린에서는 **문장**이다. <br/>

**타입 추론** <br/>
식을 사용하는 경우 사용자가 반환 타입을 적지 않아도 컴파일러가 함수 본문 식을 분석해서 식의 결과 타입을 함수 반환 타입으로 정함.
</details>

### 변경 가능한 변수와 변경 불가능한 변수
**val**(값을 뜻하는 value): 변경 불가능한 참조를 저장하는 변수. val 로 선언된 변수는 초기화 이후 재대입이 불가능. 자바의 final 과 같은 의미. <br/>
1. val 변수가 한 초기화 문장만 실행됨을 알 수 있다면 조건에 따라 여러 값으로 초기화 가능
    ```kotlin
    val message: String
    if (canPerformOperation()) {
        message = "Success"
    } else {
        message = "Failed"
    }
    ```
2. val 은 참조에 한해서만 불변이다. 참조를 가리키는 값은 변경 될 수 있음.
    ```kotlin
   val languages = arrayListOf("Java")
   languages.add("Kotlin")
   ```

**var**(변수를 뜻하는 variable): 변경 가능한 참조. 변수의 값이 바뀔수 있음. <br/>
1. 변수의 값을 변경 가능하지만 변수 타입은 고정되어 바뀌지 않음.<br/>
    변수 선언 시점의 초기값을 통해서 변수 타입을 추론한다.

> 기본적으로는 모든 변수를 val 키워드를 사용해 불변 변수로 선언, 필요할 때만 var 로 변경하라.

<details>
<summary>문자열 접합 연산</summary>

`println("Hello, $name!")` 과 같은 연산은 자바의 문자열 '+' 연산과 같이 <br/>
`StringBuilder` 를 사용하고 상수와 변수의 값을 `append` 로 문자열 빌더 뒤에 추가한다.
자바의 경우는 `StringBuilder` 를 사용하는 바이트 코드를 생성해준다.
</details>

### 코틀린에서의 클래스
1. 코틀린에서 클래스 기본 접근제어자는 public 으로 생략시 public 으로 지정된다.
2. 필드와 접근자를 합쳐 **프로퍼티**라고 부르며, 코틀린에서는 자바의 필드와 접근자 메소드를 완전 대체한다.
3. 프로퍼티 선언시 `val` 과 `var`을 사용한다. 프로퍼티 선언시 디폴트 접근자를 구현을 제공한다.
   > `val`의 경우 게터를 선언한다. <br/>
   > `var`의 경우 게터와 세터 두가지를 모두 선언한다.
4. 프로퍼티 선언시 자바와 마찬가자로 **private 으로 디폴트 필드**가 선언 된다. <br/> 
   **private 선언된 필드**는 **게터**를 통해 외부로 접근 되는 방식
5. 코틀린에서는 프로퍼티를 직접 사용한다.
    ```kotlin
   person.isMarried = false  // setter
   println(person.isMarried) // getter 
   ```
6. 커스텀 게터 사용시 프로퍼티값을 매번 계산하여 사용할 수 있다.
    > 프로퍼티에서는 backing field 라고 부르는 값을 저장하기 위한 필드가 있다.
   >  ```kotlin
   > class Rectangle(val height: Int, val width: Int) {
   >     val isSquare: Boolean
   >         get() {
   >             return height == width
   >         }
   > }
   > ```
   > 매번 프러퍼티에 접근할 때마다 게터가 값을 매번 다시 계산하여 필드에 저장한다.



## 📕 참고 링크
**다음의 링크를 참고했습니다.**

https://everyday-develop-myself.tistory.com/344
