# 3. 함수 정의와 호출

### 코틀린 컬렉션
코틀린은 자체 컬렉션을 제공하지 않는다.
표준 자바 컬렉션을 사용한다.

기본적으로 디폴트 `toString` 구현을 지원한다.<br/>
List 의 `max`, `last` 함수도 기본적으로 확장함수이다.

1. vararg<br/>
기본적으로 자바에서도 지원하는 기능이나, 코틀린에서는 문법이 다르다.<br/>
`*` -> spread 연산자 `varage` -> 가변길이인자 변경자
```kotlin
fun main(args: Array<String>) {
    val list = listOf("args: ", *args)
    println(list)
}
```

2. 중위 함수 호출<br/>
중위 호출은 일반메소드나 확장함수에 인자가 하나뿐일 경우 사용할 수 있다.<br/>
함수를 중위 호출에 사용하게 하고 싶으면 infix 변경자를 함수 선언 앞에 추가해야한다.
```kotlin
infix fun Any.to(other: Any) = Pair(this, other)

1.to("one")
1 to "one"
```

3. 구조 분해 선언<br/>
```kotlin
val (number, name) = 1 to "one"
```
`withIndex` 의 경우도 컬렉션과 함께 구조 분해 선언을 통해 인덱스를 접근할 수 있다.

### 코틀린 함수
#### 이름 붙인 인자
코틀린에서는 인자이 이름을 명시할 수 있다.
다만 자바에서는 파라미터 명시가 불가능하기에 이를 유의해야한다.<br/>
자바 8 이후, 코틀린은 JDK 6과 호환이 가능하다고 한다.

#### 디폴트 파라미터
디폴트 파라미터값을 지정해 기존의 오버로딩이 쓸데없이 많이 생기는 문제를 줄일 수 있다.<br/>
자바에서 디폴트 파라미터를 지원하지 않기에 코틀린 함수 호출시 모든 인자를 명시해 주어야한다.
(우회하는 방법 `@JvmOverloads` 어노테이션을 추가를 통해 마지막 파라미터들인 경우 생략 가능)

### 최상위 함수와 프로퍼티
기본적으로 클래스 내부에 함수 혹은 프로퍼티 선언시에
자동적으로 내부 파일명으로 클래스의 메소드, 프로퍼티로 선언되어 이를 외부에서 사용할 수 있다.

기존의 경우 항상 클래스 내부에 직접 메소드 혹스 파라미터를 넣어야하는 강제성이 있었는데 이를 해결 할 수 있다.
다만, 이또한 패키지 별로 같은 클래스 내에 선언되는 것으로 패키지 선언 별로 각각의 책임을 잘 생각해 선언해야겠다.

정적 상수와 같이 선언하려면 아래와 같이 사용한다.
```kotlin
const val MAX_SIZE = 10000
```

### 확장 함수와 프로퍼티
기존의 자바 코드를 코틀린으로 변환하기 어려운 것을 확장 함수를 통해 해당 클래스의
멤버 메소드 처럼 사용할 수 있다.
이때 확장함수를 가지게 되는 클래스의 이름을 `수신 객체 타입`라고 한다.
확장 함수를 호출하는 클래스의 객체는 `수신 객체` 라고 부른다.

이때 확장 함수 본문에서 this 를 통해 수신 객체를 가리킬 수 있으며, this 또한 생략하면서
해당 객체의 메소드나 프로퍼티를 바로 사용할 수 있다. 다만 `private`, `protected` 의 경우는 사용불가하다.

#### 확장 함수
확장함수를 선언하면, 내부적으로 클래스내에 수신 객체를 첫번째 인자로 받는 정적 메소드가 생긴다.
이는 다른 어댑터를 사용하지 않아도 되는 장점이 있다.

확장함수는 따라서 정적 메소드가 가지는 특징을 가지기 때문에 오버라이드 불가능하다.

#### 확장 프로퍼티
확장 프로퍼티의 경우 클래스내에 수신 객체내 프로퍼티를 가진다.
이는 백킹 필드가 없기 때문에 기본적인 게터 구현이 불가능하다 따라서 최소 게터는 커스텀 정의해 두어야한다.

### 문자열과 정규식
#### 코틀린 split 함수
`split`는 정규식(Regex)을 파라미터로 받는 문자열 분리 확장함수이다.
정규식 또한 `toRegex()` 를 통해 문자열을 정규식으로 변환가능하다.

- 이하 생략

### 로컬 함수와 확장
하나의 함수에서 중첩되는 로직이 많을경우 이를 한 함수 내에서 중첩 시킬 수 있다.
```kotlin
class User(val id: Int, val name: String, val address: String)

fun User.validateBeforeSave() {
    fun validate(value: String, fieldName: String) {
        if (value.isEmpty()) {
            throw IllegalArgumentException(
                "Can't save user $id: empty $fieldName")
        }
    }
    validate(name, "Name")
    validate(address, "Address")
}
```
