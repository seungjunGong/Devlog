# 5. 람다로 프로그래밍

> **용어 정리**<br/>
> **람다 식 또는 람다**: 다른 함수에 넘길 수 있는 작은 코드 조각<br/>
> **멤버 참조**: 프로퍼티나 메소드를 단 하나만 호출하는 함수 값을 만들어준다.<br/>
> 이는 프로퍼티, 함수, 생성자, 확장 함수까지도 적용이 가능하다.<br/>
> **SAM(Single Abstract Method)**: 단일 추상 메소드

### 람다 캡쳐
람다는 기본적으로 객체를 생성해서 전달한다.

다만 매번 생성하냐, 그건 아니다.<br/>
캡처 하는 값이 없는 람다: 한번만 인스턴스를 만들고 재사용한다.
외부 변수를 캡처하는 람다: 람다 객체 안에 새로운 값을 저장해야하기 떄문에 매번 새로운 객체가 재생성된다.

```kotlin
Button(onClick = { viewModel.load() })
```
뷰모델은 외부 참조를 하고 있다. 따라서 매번 리컴포지션마다 새로운 람다 인스턴스가 생긴다.

```kotlin
Button(onClick = viewModel::load)
```
따라서 아래와 같이 직접 함수 참조를 전달하여 불필요한 객체 생성을 막을 수 있다.

### 람다와 컬렉션

**filter 와  map**
컬렉션의 기반이 되는 함수

`filter`: 컬렉션을 이터레이션하면서 주어진 람다에 각 원소를 넘겨 람다가 true를 반환하는 원소만 모으는 함수<br/>
`map`: 컬렉션을 이터레이션하면서 주어진 람다에 각 원소를 적용한 값을 모아 새 컬렉션을 만드는 함수<br/>
*Map 에 적용을 할때에는 filterKeys, filterValues 와 mapKeys, mapValues 를 사용해 걸러내어 변환한다.*

**조건식 함수 적용**
- `all`: 모든 원소가 해당 람다(조건식) 을 만족하는 지 판단하는 함수 (== !any)
- `any`: 조건식을 만족하는 원소가 하나라도 있는 지 판단하는 함수 (== !all)
- `count`: 조건식을 만족하는 원소의 갯수를 세는 함수
- `find`: 조건식을 만족하는 원소를 찾는 함수 (== firstOrNull)

**groupBy**
컬렉션을 특성에 따라 여러 그룹으로 나눌때 사용

ex. 첫 글자만 나누는 함수
```kotlin
val list = listOf("a", "ab", "b")
println(list.grouBy(String::first))
```

**컬렉션 안의 중첩된 원소 처리**<br/>
`flatMap`: 인자로 주어진 람다를 컬렉션의 모든 객체에 적용, 중첩된 리스트의 원소를 한 리스트로 모을때 사용
```kotlin
val strings = listOf("abc", "def")
println(strings.flatMap { it.toList() })
```
`flatten`: flatMap 과 같이 중첩된 리스트 원소를 한 리스트로 모을때 사용하나, 변환해야할 내용이 없을 경우에 사용

**그외 다른 함수**
- maxBy : 가장 큰 원소를 찾기 위해 비교에 사용할 값을 돌려주는 함수
- joinToString: 리스트의 원소를 다른 방식을 통해 문자열로 변환하고 싶은 경우 사용
  ```kotlin
  val names = people.joinToString(separator = " ", transform = { p: Person -> p.name })
  ```
- forEach: 컬렉션의 모든 원소에 대해 람다를 호출하는 함수

### 지연 lazy 컬렉션 연산
기존의 컬렉션 함수는 결과를 즉시 생성하여 컬렉션 함수 연쇄시 계산 중간 결과를 임시로 담는 점이 있음.<br/>
시퀀스를 사용해 중간 임시 컬렉션을 사용하지 않고 컬렉션 연산을 연쇄한다.
시퀀스는 중간 연산과 최종 연산으로 나뉘며,연산의 결과 값을 사용할 필요가 없을 경우 이전 중간 연산을 수행하지 않는다.

> **tip. 시퀀스의 중간 연산을 바로 수행하지 않는 점 때문에 컬렉션 연산 호출 순서에 따라 성능이 달라질 수 있다.**<br/>
> 예를 들어, `map` 과 `filter` 를 사용하는 경우 `filter` 를 먼저 사용하면 각 원소에 대해 연산을 한번에 
> 수행하기 때문에 처음에 `map`(원소마다 전체 적용) 을 사용하는 방식보다 효율적이다.


**사용법**<br/>
- `generateSequence` 를 이용한 방식
- `asSequence` 를 이용한 방식
```kotlin
people.asSequence()                 // 원본을 시퀀스로 변환
  .map(Person::name)                // 컬렉션 함수 사용
  .filter { it.startsWith("A") }
  .toList()                         // 시퀀스를 리스트 변환
```

### 함수형 인터페이스 활용
함수형 인터페이스란? 단 하나의 추상 메서드만 가진 인터페이스
코틀린 람다는 인스턴스이기 때문에 무명 클래스와 비슷하게 동작하나,
람다 캡처를 하지 않는 경우에 동일한 인스턴스를 사용한다는 차이가 있다.

그렇다면 람다 캡처를 하는 경우에는 인스턴스의 생성을 방지하려면 inline 함수를 사용하면 된다.
inline 함수의 경우, 함수 블럭 코드 자체를 복붙해버리기에 객체가 생성되지 않는다.

SAM 생성자: 람다를 함수형 인터페이스의 인스턴스로 변환할 수 있게 컴파일러가 자동으로 생성한 함수

### 수신객체 지정 람다
[링크 참조로 대체](https://velog.io/@last_game/Kotlin-Scope-%ED%95%A8%EC%88%98%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90)