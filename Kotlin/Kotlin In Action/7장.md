# 7. 연산자 오버로딩과 기타 관례

**용어 및 개념 정리**
 
- kotlin convention: 어떤 언어 기능과 미리 정해진 이름의 함수를 연결해주는 기법
- 식별자 비교 연산자: `===` 객체가 동일한지 확인한다. 메모리 주소값을 비교하는 방식

### 산술 연산자 오버로딩

코틀린에서는 컬렉션에 원소를 추가하거나 클래스의 메소드를 산술 연산자로 변환해서 사용할 수 있다.

ex. Point 클래스에서 산술 연산자 변환

```kotlin
data class Point(val x: Int, val y: Int) {
    operator fun plus(other: Point): Point {
        return Point(x + other.x, y + other.y)
    }
}

val p1 = Point(10, 20)
val p2 = Point(30, 40)
println(p1 + p2)
```

`+ 연산자`를 사용하기 위해서는 다음의 과정이 필요하다.

- `plus` 함수 오버로딩
- `operator` 연산자 붙이기

이처럼 산술연산자에 대한 연산자 함수를 지원하기 때문에 이를 오버로딩해서 구현하면 된다.

혹은, 외부 클래스에 대해서 산술 연산자를 정의하기 위해서는 확장 함수로도 정의해서 구현한다.

오버로딩 가능한 이항 산술 연산자

| **식** | **함수 이름** |
| --- | --- |
| **a * b** | **times** |
| **a / b** | **div** |
| **a % b** | **mod (1.1 부터 rem)** |
| **a + b** | **plus** |
| **a - b** | **minus** |

해당 연산자를 통해 구현한 함수도 실제 연산자 우선 순위를 따른다.

다만, 이는 교환법칙은 지원하지 않는다.

⇒ `객체.함수(x)` 와 같이 `객체 연산자 x` 와 같이 사용한다. 순서 바꾸기 불가능

비트 연산자에 대한 연산자 함수

코틀린은 표준 숫자 타입에 대해서 비트 연산자를 정의하지 않는다. 커스텀 타입에서 비트연산자를 정의 할 수도 없다.

⇒ 대신, 중위 연산자 표기법을 지원하는 일반 함수를 사용해 비트 연산을 수행한다.

- `sh1` : 왼쪽 시프트 (자바 `<<`)
- `shr` : 부호 유지 오른쪽 시프트 (자바 `>>`)
- `ushr` : 0으로 부호 설정 오른쪽 시프트 (자바 `>>>`)
- `and` : 비트 곱 (자바 `&`)
- `or` : 비트 합 (자바 `|`)
- `xor` : 비트 배타 합 (자바 `^`)
- `inv` : 비트 반전 (자바 `~`)

### 복합 대입 연산자 오버로딩

연산자 메소드 오버로딩은 `+=`, `-=` 와 같은 복합 대입 연산자도 지원한다.

복합 대입 연산자도 따로 메소드를 정의해서 사용할 수 있다.

```kotlin
operator fun <T> MutableCollection<T>.plusAssign(element: T) {
    this.add(element)
}
```

이론적으로 코드에 `+=` 를 `plus` 와 `plusAssgin` 둘다 컴파일 할수 있기에

두가지를 모두 정의한다면 코틀린에서는 오류를 반환한다.

따라서, 꼭 `plus`, `plusAssign` 연산을 하나만 작성해야한다.

컬렉션에서는 다음과 같이 정의 된다.

`+` 와 같은 산술 연산자 → 컬렉션을 두개를 합친, 새로운 컬렉션 반환

`+=` 와 같은 복합 대입 연산자 → 컬렉션 `add` , 객체 내부 상태 변화

### 단항 연산자 오버로딩

단한 영산자는 `-x`, `+x` 와 같은 단일 연산자를 붙인 형태로 마찬가지로 `operator` 와 `오버로딩`을 통해 구현 할 수 있다.

오버로딩가능한 단항 산술 연산자

| **식** | **함수 이름** |
| --- | --- |
| **+a** | **unaryPlus** |
| **-a** | **unaryMinus** |
| **!a** | **not** |
| **++a, a++** | **inc** |
| **--a, a--** | **dec** |

`++a`, `a--` 와 같은 전위, 후위 증감 연산자의 경우는 각각의 특성에 따라 실행전 실행 후 반영이 달라진다.

### 비교 연산자 오버로딩

자바에서 `==` 는 `equals` 와 같은 역할을 한다.

이처럼 코틀린에서도 `equals` 와 `compareTo` 를 통해 비교 연산자 오버로딩을 수행할 수 있다.

**equals**

`==` 와 `!=` 에 대해서 `equals` 내부 수행 결과에 대해서 `true` `fasle` 값은 반대의 결과가 나온다.

내부에서 null 체킹을 수행해 불리언 타입을 반환하기에,

null 이 될 수 있는 값에도 적용이 가능하다.

> `a == b`    →    `a?.equals(b) ?: (b == null)`
>

위는 기본적으로 처리되는 `quals` 처리 식이라고 보면된다.

아래는 equals 오버라이딩 예이다.

```kotlin
class Point(val x: Int, val y:Int) {
    override fun equals(obj: Any?): Boolean {    // Any 가 가진 equals 오버라이딩
        if (obj === this) return true            // 파라미터가 동일 객체인지 확인
        if (obj !is Point) return false          // Point 타입 확인
        return obj.x == x && obj.y == y          // 스마트 캐스트하여 접근
    }
}

println(Point(10, 20) != Point(5, 5))
true
```

`equals` 자체는 `Any` 에서 정의되어 `operator` 변경자가 붙여있기에 따로 오버라이딩시에 붙일 필요는 없다.

**compareTo**

자바에서 정렬이나 최댓값, 최솟값 등 비교 알고리즘에서는 `Comparable` 인터페이스를 구현한다.

`Compareable` 인터페이스의 경우에 `compareTo` 메소드를 통해 객체의 크기를 비교해 정수로 나타낸다.

코틀린에서는 해당 compareTo 에 대해서 비교 연산자 >, <. <=, >= 를 변환해서 컴파일된다.

compareTo 는 Int 를 반환한다.

> `a >= b`    →    `a.compareTo(b) >= 0`
>

위는 `compareTo` 가 일반적으로 변환되는 방식이다.

```kotlin
class Person(
    val firstName: String, val lastName: String
) : Comparable<Person> {
    override fun compareTo(other: Person): Int {
        return compareValuesBy(this, other, Person::lastName, Person::firstName)
    }
}

println("abc" < "bac")
true
```

`compareTo` 도 `equals` 와 마찬가지로 `operator` 변경자가 붙여있기에 따로 오버라이딩시에 붙일 필요는 없다.

### 컬렉션 Convention

**인덱스 원소 접근**

맵 원소 접근할때와 같이 key 를 통해서 `get`, `set` 연산자 함수를 통해 접근이 가능하다.

```kotlin
operator fun Point.get(index: Int): Int {
    return when(index) {
        0 -> x
        1 -> y
        else -> 
            throw IndexOutOfBoundsException("Invalid coordinate $index")
    }
}

val p = Point(10, 20)
println(p[1])
20
```

`set` 의 경우, 프로퍼티가 `var` 인경우 따로 해당 파라미터로 전달 받은 값을 정의해서 사용할 수 있겠다.

**in**

`in` 연산자는 `contains` 와 대응 되는 함수이다.

마찬가지로 `operator` 를 사용한다.

사각형 영역 안에 좌표가 들어가는지 판단하는 함수

```kotlin
data class Rectangle(val upperLeft: Point, val lowerRight: Point)

operator fun Rectangle.contains(p: Point): Boolean {
    return p.x in upperLeft.x until lowerRight.x &&
       p.y in upperLeft.y until lowerRight.y
}

val rect = Rectangle(Point(10, 20), Point(50, 50))
println(Point(20, 30) in rect)
```

**rangeTo**

범위를 만들기 위해서는  `..` 구문을 사용해서 표기할 수 있는데(ex. `1..10`),

`rangeTo` 함수를 간략하게 표기 할수 있다.

> `start..end`    →    `start.rangeTo(end)`
>

`rangeTo` 함수를 통해 범위를 반환한다.

코틀린 표준 라이브러리에는 모든 `Comparable` 객체에 대해서 `rangeTo` 함수를 사용한다.

```kotlin
operator fun <T: Comparable<T>> T.rangeTo(that: T): ClosedRange<T>
```

`LocalDate` 에서 `rangeTo` 를 사용해 Comparable 에 대한 확장 함수로 구현되어 있다.

```kotlin
val now = LocalDate.now()
val vacation = now..now.plusDay(10)  // 오늘부터 10일까지
println(now.plusWeeks(1) in vacation)
true
```

**반복문 in**

`for (x in lis) { … }` 와 같이 `list.iterator()` 를 호출해서 이터레이터에 대한 `hasNext` 와 `next` 호출을 반복한다.

iterator 을 직접 구현하면 범위 객체를 for 루프에 직접 사용이 가능하다.

### 구조 분해 선언과 component 함수

구조 분해 선언(`destructuring declartion`) 은 복합적인 값을 분해해 여러 변수를 한번에 초기화 가능하게 한다.

```kotlin
val p = Point(10, 20)
val (x, y) = p
println(x)

10
```

> `val (a, b) = p`    →    `val a = p.component1() val b = p.component2()`
>

기본적으로 componentN 함수를 컴파일러가 자동으로 만들어준다.

```kotlin
class Point(val x: Int, val y: Int) {
    operator fun component1() = x
    operator fun component2() = y
}
```

구조 분해 선언은 함수에서 여러 값을 반환하고자 할 때 유용하다.

여러 값을 한번에 반환해야하는 함수가 있다면 해당 모든 값이 들어갈 데이터 클래스를 정의하고 해당 함수의 반환타입을 데이터 클래스로 변환한다.



즉, 데이터 클래스의 경우도 componentN 이 기본적으로 적용되기에 이를 분리해서 다루고자 할때 유용하다.

코틀린 표준 라이브러리에서는 맨 앞의 다섯개의 원소에 대해서 compoentN 을 제공한다고 한다.

compoentN 을 사용하는 대표적은 예는 다음과 같다.

- `map iterator`
- `Pair`, `Triple`

### 위임 프로퍼티

위임 프로퍼티(`delegated property`) 란 get, set 과 같은 로직을 하나의 delegate 클래스에 정의하여 해당 로직을 위임하는 것이 목적이다.

```kotlin
class Foo {
    var p: Type by Delegate()
}

---
class Foo {
    private val delegate = Delegate() // 컴파일러가 생성
    var p: Type
    set(value: Type) = delegate.setValue(..., value)
    get() = delegate.getValue(...)
}

===
class Delegate {
    operator fun getValue(...) { ... }  // 위 두 get, set 메소드는 by 에 의해 위임되어 사용된다.
    operator fun setValue(...) { ... }
}
```

`p` 프로퍼티는 접근자 로직을 다른 객체에게 위임한다.

delegate 패턴을 사용하면 중복되는 로직을 하나의 delegate 로 처리할수 있다.

위임 프로퍼티는 **지연 초기화**를 사용할 때 사용 할 수 있다.

지연 초기화를 사용하면 초기에 null 값을 지정할 필요 없이 사용이 가능하다.

`lazy()`: 위임 객체를 반환하는 표준 라이브러리 함수

lazy 함수는 getValue 메소드가 있는 객체를 반환한다.

초기화 시점해 해당 lazy 의 람다를 호출하고 이를 반환한다.

```kotlin
class Person(val name: String) {
    val emails by lazy { loadEmails(this) }
}
```

- lazy 함수는 스레드 안전하다.
- 비용이 큰 객체에 적합하다.

위임 프로퍼티의 또다른 예로는 **변경감지**가 있다.

`observable`: 위임 객체에 대해서 변경 감지를 하는 함수

```kotlin
var count by Delegates.observable(0) { _, old, new ->
    println("$old → $new")
}
```

- 값 변경시 UI, 로깅, 이벤트 트리거

`vetoable`: 변경시 차단하는 방법

```kotlin
var age by Delegates.vetoable(0) { _, _, new ->
    new >= 0
}
```

- 잘못된 값이 들어오지 않게 하기 위함

동적인 객체를 만들떄도 사용이 가능하다.(`expando object`)

연락처 관리 시스템과 같이 맵을 통해서 처리되어하는 경우 해당 프로퍼티가 가져야 할 역할을 쉽게 전달 할 수 있다.

```kotlin
class Person {
    private val _attributes = hashMapOf<String, String>()
    fun setAttribute(attrName: String, value: String) {
        _attributes[attrName] = value
    }
    val name: String by _attributes // 위임 프로퍼티
}
```

Map 으로도 사용 가능하지만 위는 hashMap 을 사용해 getValue, setValue 확장 함수를 정의하여 위임한 방식이다.
