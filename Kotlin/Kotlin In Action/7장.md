# 7. 연산자 오버로딩과 기타 관례

**용어 및 개념 정리**
 
- kotlin convention: 어떤 언어 기능과 미리 정해진 이름의 함수를 연결해주는 기법
- 식별자 비교 연산자: `===` 객체가 동일한지 확인한다. 메모리 주소값을 비교하는 방식

### 산술 연산자 오버로딩

코틀린에서는 컬렉션에 원소를 추가하거나 클래스의 메소드를 산술 연산자로 변환해서 사용할 수 있다.

ex. Point 클래스에서 산술 연산자 변환

```kotlin
data class Point(val x: Int, val y: Int) {
    operator fun plus(other: Point): Point {
        return Point(x + other.x, y + other.y)
    }
}

val p1 = Point(10, 20)
val p2 = Point(30, 40)
println(p1 + p2)
```

`+ 연산자`를 사용하기 위해서는 다음의 과정이 필요하다.

- `plus` 함수 오버로딩
- `operator` 연산자 붙이기

이처럼 산술연산자에 대한 연산자 함수를 지원하기 때문에 이를 오버로딩해서 구현하면 된다.

혹은, 외부 클래스에 대해서 산술 연산자를 정의하기 위해서는 확장 함수로도 정의해서 구현한다.

오버로딩 가능한 이항 산술 연산자

| **식** | **함수 이름** |
| --- | --- |
| **a * b** | **times** |
| **a / b** | **div** |
| **a % b** | **mod (1.1 부터 rem)** |
| **a + b** | **plus** |
| **a - b** | **minus** |

해당 연산자를 통해 구현한 함수도 실제 연산자 우선 순위를 따른다.

다만, 이는 교환법칙은 지원하지 않는다.

⇒ `객체.함수(x)` 와 같이 `객체 연산자 x` 와 같이 사용한다. 순서 바꾸기 불가능

비트 연산자에 대한 연산자 함수

코틀린은 표준 숫자 타입에 대해서 비트 연산자를 정의하지 않는다. 커스텀 타입에서 비트연산자를 정의 할 수도 없다.

⇒ 대신, 중위 연산자 표기법을 지원하는 일반 함수를 사용해 비트 연산을 수행한다.

- `sh1` : 왼쪽 시프트 (자바 `<<`)
- `shr` : 부호 유지 오른쪽 시프트 (자바 `>>`)
- `ushr` : 0으로 부호 설정 오른쪽 시프트 (자바 `>>>`)
- `and` : 비트 곱 (자바 `&`)
- `or` : 비트 합 (자바 `|`)
- `xor` : 비트 배타 합 (자바 `^`)
- `inv` : 비트 반전 (자바 `~`)

### 복합 대입 연산자 오버로딩

연산자 메소드 오버로딩은 `+=`, `-=` 와 같은 복합 대입 연산자도 지원한다.

복합 대입 연산자도 따로 메소드를 정의해서 사용할 수 있다.

```kotlin
operator fun <T> MutableCollection<T>.plusAssign(element: T) {
    this.add(element)
}
```

이론적으로 코드에 `+=` 를 `plus` 와 `plusAssgin` 둘다 컴파일 할수 있기에

두가지를 모두 정의한다면 코틀린에서는 오류를 반환한다.

따라서, 꼭 `plus`, `plusAssign` 연산을 하나만 작성해야한다.

컬렉션에서는 다음과 같이 정의 된다.

`+` 와 같은 산술 연산자 → 컬렉션을 두개를 합친, 새로운 컬렉션 반환

`+=` 와 같은 복합 대입 연산자 → 컬렉션 `add` , 객체 내부 상태 변화

### 단항 연산자 오버로딩

단한 영산자는 `-x`, `+x` 와 같은 단일 연산자를 붙인 형태로 마찬가지로 `operator` 와 `오버로딩`을 통해 구현 할 수 있다.

오버로딩가능한 단항 산술 연산자

| **식** | **함수 이름** |
| --- | --- |
| **+a** | **unaryPlus** |
| **-a** | **unaryMinus** |
| **!a** | **not** |
| **++a, a++** | **inc** |
| **--a, a--** | **dec** |

`++a`, `a--` 와 같은 전위, 후위 증감 연산자의 경우는 각각의 특성에 따라 실행전 실행 후 반영이 달라진다.

### 비교 연산자 오버로딩

자바에서 `==` 는 `equals` 와 같은 역할을 한다.

이처럼 코틀린에서도 `equals` 와 `compareTo` 를 통해 비교 연산자 오버로딩을 수행할 수 있다.

**equals**

`==` 와 `!=` 에 대해서 `equals` 내부 수행 결과에 대해서 `true` `fasle` 값은 반대의 결과가 나온다.

내부에서 null 체킹을 수행해 불리언 타입을 반환하기에,

null 이 될 수 있는 값에도 적용이 가능하다.

> `a == b`    →    `a?.equals(b) ?: (b == null)`
>

위는 기본적으로 처리되는 `quals` 처리 식이라고 보면된다.

아래는 equals 오버라이딩 예이다.

```kotlin
class Point(val x: Int, val y:Int) {
    override fun equals(obj: Any?): Boolean {    // Any 가 가진 equals 오버라이딩
        if (obj === this) return true            // 파라미터가 동일 객체인지 확인
        if (obj !is Point) return false          // Point 타입 확인
        return obj.x == x && obj.y == y          // 스마트 캐스트하여 접근
    }
}

println(Point(10, 20) != Point(5, 5))
true
```

`equals` 자체는 `Any` 에서 정의되어 `operator` 변경자가 붙여있기에 따로 오버라이딩시에 붙일 필요는 없다.

**compareTo**

자바에서 정렬이나 최댓값, 최솟값 등 비교 알고리즘에서는 `Comparable` 인터페이스를 구현한다.

`Compareable` 인터페이스의 경우에 `compareTo` 메소드를 통해 객체의 크기를 비교해 정수로 나타낸다.

코틀린에서는 해당 compareTo 에 대해서 비교 연산자 >, <. <=, >= 를 변환해서 컴파일된다.

compareTo 는 Int 를 반환한다.

> `a >= b`    →    `a.compareTo(b) >= 0`
>

위는 `compareTo` 가 일반적으로 변환되는 방식이다.

```kotlin
class Person(
    val firstName: String, val lastName: String
) : Comparable<Person> {
    override fun compareTo(other: Person): Int {
        return compareValuesBy(this, other, Person::lastName, Person::firstName)
    }
}

println("abc" < "bac")
true
```

`compareTo` 도 `equals` 와 마찬가지로 `operator` 변경자가 붙여있기에 따로 오버라이딩시에 붙일 필요는 없다.